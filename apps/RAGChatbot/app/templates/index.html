<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>補助金・支援制度ナビ（RAGデモ）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Bootstrap 5 -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Optional: your custom css (kept) -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/app.css') }}">
</head>
<body>

  <header class="py-3 mb-3 border-bottom" style="background: var(--yolk-bg)">
    <div class="container">
      <div class="d-flex align-items-center justify-content-between">
        <div class="d-flex align-items-center gap-2">
          <span class="badge rounded-pill logo-badge px-3 py-2">RAGデモ</span>
          <h1 class="h4 m-0">補助金・支援制度ナビ</h1>
        </div>
        <div class="text-muted small">Demo UI (Bootstrap 5)</div>
      </div>
    </div>
  </header>

  <main class="container pb-5">
    <div class="row g-4">
      <div class="col-lg-8">

        <!-- Chat Card -->
        <div class="card chat-card shadow-sm">
          <div class="card-header bg-transparent">
            <div class="d-flex flex-wrap align-items-center gap-2">
              <strong>検索モード</strong>
              <select id="mode" class="form-select form-select-sm w-auto">
                <option value="doc">Document（ローカル取り込み）</option>
                <option value="web">Web（SerpAPIで検索）</option>
                <option value="hybrid">Hybrid（両方）</option>
              </select>
              <span id="status" class="ms-auto small text-muted" aria-live="polite"></span>
              <button id="reset" class="btn btn-sm btn-outline-secondary" type="button">リセット</button>
            </div>
          </div>

          <div id="chat" class="chat-stream" aria-live="polite" aria-relevant="additions">
            <!-- 初期ガイダンス -->
            <div class="msg ai">
              <div class="avatar">AI</div>
              <div class="bubble">
こんにちは！補助金・支援制度の質問にお答えします。<br/>
例：「子育て家庭の給付金制度について教えて」
              </div>
            </div>
          </div>

          <div class="card-body border-top">
            <div class="composer">
              <label for="q" class="form-label mb-2">質問</label>
              <textarea id="q" rows="3" class="form-control" placeholder="例：子育て家庭の給付金制度について教えて"></textarea>
              <div class="d-flex gap-2 align-items-center mt-2">
                <button id="ask" class="btn btn-yolk" type="button">送信</button>
              </div>
            </div>
          </div>
        </div>

        <!-- 結果（プレーン出力も残す場合） -->
        <div class="section-card mt-3 d-none">
          <h3 class="h6">結果（テキスト）</h3>
          <pre id="answer" class="answer mb-0"></pre>
          <div id="sources"></div>
        </div>

      </div>

      <div class="col-lg-4">
        <!-- 投入済みファイル一覧 -->
        <div class="section-card">
          <h3 class="h6 mb-3">投入済みファイル</h3>
          {% if not has_index %}
            <p class="muted">まだインデックスが作成されていません。まずは「再インデックス」を実行してください。</p>
          {% else %}
            {% if files and files|length > 0 %}
              <div class="table-responsive">
                <table class="table table-sm align-middle" aria-label="Indexed documents">
                  <thead>
                    <tr><th>ファイル名</th><th>チャンク数</th><th>ページ数</th></tr>
                  </thead>
                  <tbody>
                  {% for f in files %}
                    <tr>
                      <td>{{ f.name }}</td>
                      <td>{{ f.chunks }}</td>
                      <td>{{ f.pages if f.pages is not none else "-" }}</td>
                    </tr>
                  {% endfor %}
                  </tbody>
                </table>
              </div>
            {% else %}
              <p class="muted">インデックスはありますが、ファイルが見つかりませんでした。</p>
            {% endif %}
          {% endif %}
        </div>

        <!-- アップロード / インデックス -->
        <div class="section-card mt-3">
          <h3 class="h6">インデックス作成（PDF / TXT / Markdown）</h3>
          <p class="muted">ファイルを選んでアップロードすると <code>data/pdf</code> に保存されます。その後「再インデックス」を押すと検索に反映されます。</p>

          <div class="mb-2">
            <input id="files" type="file" multiple accept=".pdf,.txt,.md,.markdown" class="form-control"/>
          </div>
          <div class="d-flex gap-2 flex-wrap">
            <button id="upload" class="btn btn-outline-secondary btn-sm">
              <span class="spinner-border spinner-border-sm me-1 d-none" role="status" aria-hidden="true"></span>
              <span class="btn-label">アップロード</span>
            </button>
            <button id="ingest" class="btn btn-outline-secondary btn-sm">
              <span class="spinner-border spinner-border-sm me-1 d-none" role="status" aria-hidden="true"></span>
              <span class="btn-label">インデックス</span>
            </button>
          </div>
          <pre id="ingestOut" class="mt-3 small mb-0" style="max-height: 180px; overflow:auto;"></pre>
        </div>
      </div>
    </div>
  </main>

  <!-- Bootstrap JS (optional, for dropdowns etc.) -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

  <script>
  // リセットボタン押したときにHTML描画する関数
  const initialGreetingHTML = `
    <div class="msg ai">
      <div class="avatar">AI</div>
      <div class="bubble">
こんにちは！補助金・支援制度の質問にお答えします。<br/>
例：「子育て家庭の給付金制度について教えて」
      </div>
    </div>
  `;
  // リセット時に進行中の通信を止める
  function renderInitialGreeting() {
    const wrap = document.createElement('div');
    wrap.innerHTML = initialGreetingHTML.trim();
    return wrap.firstElementChild;
  }
  let inflightController = null;

  function abortInflight() {
    try { inflightController?.abort(); } catch(_) {}
    inflightController = null;
  }

  function resetChatUI({ resetMode = false } = {}) {
    // 1) 進行中の通信があれば中断（任意）
    abortInflight();

    // 2) チャット欄を初期状態へ
    chat.innerHTML = '';
    chat.appendChild(renderInitialGreeting());
    chat.scrollTop = 0;

    // 3) ステータスと旧出力領域をクリア
    setStatus('');
    const ansEl = $("#answer"); if (ansEl) ansEl.textContent = '';
    const srcEl = $("#sources"); if (srcEl) srcEl.innerHTML = '';

    // 4) 入力欄を空にしてフォーカス
    $("#q").value = '';
    $("#q").focus();

    // 5) モードも既定に戻す
    if (resetMode) $("#mode").value = "doc";

    // // 6)会話IDを新規採番（UI/ログ用途）
    // window.currentConversationId =
    //   (crypto.randomUUID?.() || ('c_' + Date.now() + '_' + Math.random().toString(16).slice(2)));
    // history.replaceState({}, '', `?c=${window.currentConversationId}`);
  }
  console.log('[init] inline script started');
  const $ = (s)=>document.querySelector(s);
  const chat = $("#chat");
    const setButtonLoading = (btn, loading, busyText) => {
    const spin = btn.querySelector('.spinner-border');
    const label = btn.querySelector('.btn-label');
    if (!spin || !label) return; // フォールバック
    if (loading) {
      spin.classList.remove('d-none');
      btn.disabled = true;
      btn.dataset.label = label.textContent;
      label.textContent = busyText || label.textContent;
    } else {
      spin.classList.add('d-none');
      btn.disabled = false;
      if (btn.dataset.label) label.textContent = btn.dataset.label;
    }
  };

  const runWithSpinner = async (btn, busyText, fn) => {
    setButtonLoading(btn, true, busyText);
    try { return await fn(); }
    finally { setButtonLoading(btn, false); }
  };


  /** Create message node */
  const createMsg = ({role, text, sourcesHTML}={})=>{
    const wrap = document.createElement("div");
    wrap.className = "msg " + (role === "user" ? "user" : "ai");
    const avatar = document.createElement("div");
    avatar.className = "avatar";
    avatar.textContent = role === "user" ? "You" : "AI";
    const bubble = document.createElement("div");
    bubble.className = "bubble";
    bubble.textContent = text || "";
    wrap.appendChild(avatar);
    wrap.appendChild(bubble);

    if (sourcesHTML && role !== "user") {
      const src = document.createElement("div");
      src.className = "sources";
      src.innerHTML = sourcesHTML;
      bubble.appendChild(src);
    }
    return {wrap, bubble};
  };

  /** Typing dots (AI loading) */
  const createTyping = ()=>{
    const wrap = document.createElement("div");
    wrap.className = "msg ai";
    const avatar = document.createElement("div");
    avatar.className = "avatar";
    avatar.textContent = "AI";
    const bubble = document.createElement("div");
    bubble.className = "bubble";
    bubble.innerHTML = '<span class="typing-dots" aria-label="検索中"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>';
    wrap.appendChild(avatar);
    wrap.appendChild(bubble);
    return wrap;
  };

  const scrollToBottom = ()=> chat.scrollTop = chat.scrollHeight;

  const setStatus = (html) => { $("#status").innerHTML = html || ""; };
  const showLoading = (msg="検索中です…") =>
    setStatus(`<span class="small text-muted">${msg}</span>`);

  $("#upload").onclick = async () => {
  const btn = $("#upload");
  const input = $("#files");
  if (!input.files || input.files.length === 0) {
    alert("ファイルを選んでください");
    return;
  }
  await runWithSpinner(btn, "アップロード中…", async () => {
    const fd = new FormData();
    for (const f of input.files) fd.append("files", f);
    const r = await fetch("/api/upload", { method:"POST", body: fd });
    const j = await r.json();
    $("#ingestOut").textContent = JSON.stringify(j, null, 2);
    if (j.ok) {
      // location.reload(); // ←リロードせず、必要ならUIを更新
      // 成功メッセージ
      $("#ingestOut").textContent += "\n✅ アップロード完了";
    } else {
      alert(j.error || "アップロードに失敗しました");
    }
  });
  };

  document.querySelector("#ingest").onclick = async () => {
    const btn = document.querySelector("#ingest");
    await runWithSpinner(btn, "インデックス中…", async () => {
      const r = await fetch("/api/ingest", { method: "POST" });
      const j = await r.json();
      document.querySelector("#ingestOut").textContent = JSON.stringify(j, null, 2);

      if (j.ok) {
        document.querySelector("#ingestOut").textContent += "\n✅ インデックス完了";
        // 完了表示を少し見せてからリロード
        setTimeout(() => {
          location.reload();
        }, 600);
      } else {
        alert(j.error || "再インデックスに失敗しました");
      }
    });
  };


  const buildSourcesHTML = (sources=[])=>{
  if (!sources || sources.length === 0) return "";
  return sources.map(s=>{
    const u = s.url ? `<a href="${s.url}" target="_blank" rel="noopener noreferrer">${s.title||s.url}</a>` : (s.title||"");
    const scoreVal = (s.score != null && typeof s.score.toFixed === 'function')
      ? s.score.toFixed(3)
      : (s.score != null ? s.score : "");
    const score = scoreVal !== "" ? `（score:${scoreVal}）` : "";
    const kind = s.kind ? ` [${s.kind}]` : "";
    return `<div class="src">• ${u}${score}${kind}</div>`;
  }).join("");
  };

  const ask = async ()=>{
    const btn = $("#ask");
    const query = $("#q").value;
    const mode = $("#mode").value;

    if (!query.trim()){
      alert("質問を入力してください");
      return;
    }

    // ユーザメッセージを追加
    const {wrap: userWrap} = createMsg({role:"user", text: query});
    chat.appendChild(userWrap);
    $("#q").value = "";
    scrollToBottom();

    // AIのタイピング表示
    const typing = createTyping();
    chat.appendChild(typing);
    showLoading();  // ステータス（右上）
    btn.disabled = true;

    // 既存の回答・ソースをクリア
    const ansEl = $("#answer");
    if (ansEl) ansEl.textContent = "";

    const srcEl = $("#sources");
    if (srcEl) srcEl.innerHTML = "";

    try {
      const ctrl = new AbortController();
      inflightController = ctrl;

      const r = await fetch("/api/ask", {
        method: "POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({ query: query.trim(), mode }),
        signal: ctrl.signal
      });

      // HTTPエラー時は安全に処理
      if (!r.ok) {
        typing.remove();
        const {wrap} = createMsg({role:"ai", text:`エラーが発生しました (HTTP ${r.status})`});
        chat.appendChild(wrap);
        scrollToBottom();
        return;
      }

      const j = await r.json();

      typing.remove();

      if (!j.ok) {
        const {wrap} = createMsg({role:"ai", text: j.error || "エラーが発生しました"});
        chat.appendChild(wrap);
        scrollToBottom();
        return;
      }

      const sourcesHTML = buildSourcesHTML(j.sources || []);
      const {wrap} = createMsg({role:"ai", text: j.answer || "", sourcesHTML});
      chat.appendChild(wrap);
      scrollToBottom();

      if (ansEl) ansEl.textContent = j.answer || "";
      if (srcEl) srcEl.innerHTML = sourcesHTML;

    } catch (e) {
      typing.remove();
      if (e.name === "AbortError") {
        // リセット等による中断 → 何も表示しない
        setStatus("");
        return;
      }
      const {wrap} = createMsg({role:"ai", text:"通信に失敗しました"});
      chat.appendChild(wrap);
      scrollToBottom();
    } finally {
      inflightController = null;
      setStatus("");
      $("#ask").disabled = false;
      $("#q").focus();
    }
  };

  document.addEventListener('click', (e)=>{
  const btn = e.target.closest('#ask');
  if (btn) {
    console.log('[click] ask button');
    ask();
  }
  });

  // Ctrl/Cmd + Enter
  document.addEventListener('keydown', (e)=>{
    const q = $("#q");
    if (!q) return;
    if (document.activeElement === q && e.key === "Enter" && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      console.log('[keydown] ask via shortcut');
      ask();
    }
  });
  document.addEventListener('click', (e) => {
    const btn = e.target.closest('#reset');
    if (btn) {
      resetChatUI({ resetMode: false }); // モードも初期化したいなら true
    }
  });
  </script>
</body>
</html>
